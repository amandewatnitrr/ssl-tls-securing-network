# Encryption and Hashing Overview

## Difference b/w HTTP and HTTPS

- HTTP: HyperText Transfer Protocol

  - It is a protocol used for transferring hypertext requests and information on the World Wide Web.
  - It is a stateless protocol, which means that the server does not keep any data (state) between two requests.
  - It uses port 80 for communication.
  - It is not secure, as the data is transferred in plain text.
  - It is faster than HTTPS.
  - It is used for websites that do not require sensitive information.

    ![](./imgs/Screenshot%202024-09-07%20at%208.11.42 AM.png)

    For example, when visiting this site you will see a message visible at the top saying `Your connection to this site is not secure`. This is because the site is using HTTP instead of HTTPS.

- HTTPS: HyperText Transfer Protocol Secure

  - It is a secure version of HTTP.
  - It uses port 443 for communication.
  - It uses SSL/TLS to encrypt the data before transferring it.
  - It is slower than HTTP because of the encryption process.
  - It is used for websites that require sensitive information, such as online banking, e-commerce websites, etc.
  - It is more secure than HTTP.
  - It is stateless, just like HTTP.

  ![](./imgs/what-are-the-differences-between-http-and-https-2%201.svg)

## Hashing Overview

- Hashing is the process of converting an input (or 'message') into a fixed-length string of bytes.

  ![](./imgs/1_VDRVI-0EfU2v7c43k9IIeA%201%20(traced).svg)

- Encryption is done to make data unreadable by unauthorized users. Hashing is done to verify the integrity of data
- Hash is a fixed length string of bytes that is unique to the input. This length maybe 128, 256, 512 bits etc depending on the hashing algorithm used.
- Hashing is a one-way function, meaning that it is not possible to reverse the process and get the original input from the hash.
- Hashing is used in many applications, such as password storage, digital signatures, and data integrity verification.
- Hashing algorithms are designed to be fast and efficient, so they can be used in real-time applications.
- Some common hashing algorithms are MD5, SHA-1, SHA-256, and SHA-512.
- Hashing is not encryption. Encryption is a two-way function, meaning that it is possible to decrypt the data if you have the key.
- Hashing is used to verify the integrity of data, while encryption is used to make data unreadable by unauthorized users.
- Not all Hash have a key, encryption has a key.

  ```mermaid
  graph LR
    A[Sender] -->|Input Data| B[Hash Function]
    B -->|Generated Hash| C[Sender Transmits]
    
    C --> D[Receiver]
    D -->|Data + Hash| E[Hash Function on Data]
    E -->|Hash from Received Data| F[Comparison]
    F -->|Hashes Match?| G[Data Integrity Verified]
    F -->|Hashes Don't Match?| H[Data Integrity Failed]

    class A flow;
    class B flow;
    class C flow;
    class D flow;
    class E flow;
    class F flow;
    class G flow;
    class H flow;
  ```

- Workflow:

  - Sender:
    - The Sender inputs the data, which is passed to the Hash Function. 
  - Hash Function:
    - The Hash Function computes the hash from the data and generates a Hash.
  - Transmission:
    - The Sender transmits both the Data and the generated Hash to the Receiver.
  - Receiver:
    - The Receiver gets both the data and the hash.
    - The receiver then passes the received Data through the Hash Function to generate a new hash from the data.
  - Comparison:
    - The newly generated hash from the data is compared with the hash received.
    - If the hashes match, the integrity of the data is verified. If they don’t match, it indicates that the data might have been altered or corrupted during transmission.

- Hashes are created in a way that even a small change in the data will create a completely new hash, even depending on the time of change.
- Keys are used in Hashing to validate the integrity of the sender and receiver. The key is used to generate the hash and is shared between the sender and receiver.

### MD5 (Message Digest Algorithm 5) Hashing Algorithm

- MD5 is a widely used hashing algorithm that produces a 128-bit hash value.
- It is used to verify data integrity and is commonly used in digital signatures.
- It is not recommended for security purposes as it is vulnerable to collision attacks.
- A collision attack is when two different inputs produce the same hash value.
- MD5 is fast and efficient, making it suitable for real-time applications.
- Hashes generated by MD5 are unique to the input data, meaning that even a small change in the input will produce a completely different hash.
- MD5 is not encryption, as it is a one-way function that cannot be reversed to get the original input from the hash.
- Below is the example of MD5 Hashing algorith in action on Mac OS.
  
  ![](./imgs/Screenshot%202024-09-07%20at%209.49.05 AM.png)

  If we make changes to this file `file.txt` and run the MD5 command again, we will get a different hash value, but the length of the hash will remain the same.

  The embedded MD5 Hashing Algorithm produces the hash value based on the content of the file.

### SHA (Secure Hash Algorithm) Hashing Algorithm

- SHA is a family of hashing algorithms that produce a fixed-length hash value.
- The most common SHA algorithms are SHA-1, SHA-256, and SHA-512.
- SHA-1 produces a 160-bit hash value, SHA-256 produces a 256-bit hash value, and SHA-512 produces a 512-bit hash value.
- SHA algorithms are used to verify data integrity and are commonly used in digital signatures.
- SHA-1 is no longer considered secure and is vulnerable to collision attacks.
- SHA-256 and SHA-512 are more secure and are recommended for security purposes.
- Hashes generated by SHA algorithms are unique to the input data, meaning that even a small change in the input will produce a completely different hash.
- Below is the implementation of SHA-256 Hashing Algorithm in action on Mac OS.
  
  ![](./imgs/Screenshot%202024-09-07%20at%209.57.33 AM.png)

### HMAC (Hash-based Message Authentication Code)

- HMAC is a type of message authentication code that uses a cryptographic hash function to verify the integrity and authenticity of a message.
- It combines a secret key with the message to generate a hash value that is unique to not only input data but the key that comes with it.
- The other side will get the same hash if it has the same secret key.
- HMAC is used to prevent unauthorized users from tampering with the message or data.
- It is commonly used in network security protocols, such as SSL/TLS, IPsec, and SSH.
- HMAC is more secure than traditional message authentication codes because it uses a cryptographic hash function to generate the hash value.
- HMAC can be used with any cryptographic hash function, such as MD5, SHA-1, SHA-256, and SHA-512.

## RSA (Rivest-Shamir-Adleman) Encryption

- RSA is a public-key encryption algorithm that is widely used for secure data transmission.
- It uses two keys, a public key and a private key, to encrypt and decrypt data.
- The public key is used to encrypt the data, and the private key is used to decrypt the data.
- RSA is based on the mathematical problem of factoring large prime numbers, which is considered computationally difficult.
- It is largely used in secure communication protocols in modern communication such as SSL/TLS, PGP, and SSH for secure data transmission.
- The Key length is important in RSA encryption. The longer the key, the more secure the encryption. It has key lengths of 1024, 2048, 3072, and 4096 bits.

## Using OpenSSL to Generate Key

- OpenSSL is a command-line tool that can be used to generate keys, encrypt data, and perform other cryptographic operations.
- In order to install `openssl` on Mac OS, you can use the following command:

  ```bash
  brew install openssl
  ```

- To generate a private key using OpenSSL, you can use the following command:

  ```bash
  openssl genrsa
  ```

  We can encrypt this private key using a passphrase to make it more secure.

  ```bash
  openssl genrsa -aes256 
  ```

  This command will generate a private key with a passphrase, the passphrase will be required to decrypt the private key.

  ```bash
  openssl genrsa -aes256 -out private.pem
  ```

  This command will generate a private key with a passphrase and save it to a file named `private.pem`. `pem` is the file extension for private keys, and it is commonly used in SSL/TLS certificates.

  The Public Key is also encrypted along with the private key, and we can extract the public key from the private key using the following command:

  ```bash
  openssl rsa -in private.pem -outform PEM -pubout -out public.pem
  ```

  So, in general the command looks like `openssl rsa -in <private_key_file> -outform PEM -pubout -out <public_key_file>`.
  
  Once, the command is entered, you will be asked for the passphrase to decrypt the private key, and then the public key will be extracted and saved to the file `public.pem`.

## Exploring Website Certificates and Chain of Trust

  ![](./imgs/Screenshot%202024-09-08%20at%208.32.31 AM.png)

- So, the first thing we see is a chain of trust or certificates. This is because the certificate of Instagram is signed by a Certificate Authority (CA) which is signed by another CA and so on. This is called a chain of trust.

- Here `DigiCert High Assurance EV Root CA` is the root CA, and is considered the root entity in the chain of trust. The `DigiCert SHA2 High Assurance Server CA` is the intermediate CA, and the `*.instagram.com` is the certificate of Instagram assigned by it.

- We can also see the validity of the certificate, which is untill 16th September 2024. After, this date the certificate will be invalid and the website will be considered insecure, and a new certificate will be required.

  ![](./imgs/Screenshot%202024-09-08%20at%208.40.06 AM.png)

- If we move towards the detail section, we can see the details of the certificate. The certificate is issued to `*.instagram.com`, which is the owner and is issued by `DigiCert SHA2 High Assurance Server CA`.

- In the following block, we find the details about the issuer of the certificate. It contains the Serial Number of the certificate, which is unique to the certificate and is used to identify it, if blocked or revoked, can be found in Certificate Revocation List (CRL). 

  It also contains information about the algorithm used for creating the certificate, which is `SHA-256 with RSA Encryption`.

  `Not Valid Before` and `Not Valid After` are the dates between which the certificate is valid.

  ![](./imgs/Screenshot%202024-09-08%20at%208.42.30 AM.png)

- The `Public Key Info` section contains the details about the public key used in the certificate. It contains the algorithm used for encryption, which is `RSA Encryption`. It also tells information about the key length, which is `2048 bits`. And, contains the signature along with the algorithm used for signing, which is `SHA-256 with RSA Encryption`.

  ![](./imgs/Screenshot%202024-09-08%20at%208.47.32 AM.png)

- The `Root Certificate Authourity` generally signs the certificate for itseelf, and is considered the root entity in the chain of trust. And, is the only certificate that is self-signed.
  
  But the question might come **`How do browsers trust these self signed root certificates ??`**. The answer is that the root certificate authority is already installed in the OS, and the browser trusts the root certificate authority. So, when the browser sees a certificate signed by the root certificate authority, it trusts the certificate.

- If you go to `Keychain Access` on Mac OS, you can see the root certificate authorities installed on your system. You can also see the certificates that are trusted by the system. These are just few of them.

  ![](./imgs/Screenshot%202024-09-08%20at%209.01.00 AM.png)

  This list gets updated when you update your system, and the new root certificate authorities are added to the list.